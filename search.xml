<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串表达式的计算]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[利用后缀表达式求值定义： ​ 中缀表达式： 在通常的表达式中，二元运算符总是置于与之相关的两个运算对象之间，这种表示法也称为中缀表达式 ​ 后缀表达式： 又叫逆波兰表达式 ，不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则，如：(2 + 1) 3 ， 即2 1 + 3 一个字符串表达式 s = “9 + ( 3 - 1 ) * 3 + 10 / 2” 求值的过程分为两步 (一) 将中缀表达式变为后缀表达式将中缀表达式s变为后缀表达式s_after = “9 3 1 - 3 * + 10 2 / +”，具体的规则如下 ： 首先维护两个空栈，（stack_exp）存放逆波兰表达式，(stack_ops)暂存操作符，运算结束后stack_ops必为空 循环遍历字符串(将表达式分为四种元素：1.数值；2.操作符；3. 左括号；4.右括号)，具体情况如下 1、遇到数值， 将该值入栈stack_exp 2、遇到左括号(， 将左括号入栈stack_ops 3、遇到右括号)，将stack_ops中的操作符从栈顶依次出栈并入栈stack_exp， 直到第一次遇到左括号终止操作（注意： 该左括号出栈stack_ops但不入栈stack_exp）至此消除表达式中的一对括号 4、遇到四则运算操作符号（+ - * /） 4-1、 如果stack_ops为空， 操作符入栈stack_ops ​ 4-2、 如果stack_ops不空，将stack_ops栈顶操作符与遍历到的操作符(op)比较： 4-2-1： 如果stack_ops栈顶操作符为左括或者op优先级高于栈顶操作符优先级， op入栈stack_ops，当前遍历结束 4-2-2： 如果op优先级小于或者等于stack_ops栈顶操作符， stack_ops栈顶操作符出栈并入栈stack_exp，重复4-1、 4-2直到op入栈stack_ops 5、字符串遍历结束后如果stack_ops栈不为空，则依次将操作符出栈并入栈stack_exp python代码实现如下：12345678910111213141516171819202122232425262728293031323334353637383940ops_rule = &#123; '+': 1, '-': 1, '*': 2, '/': 2&#125;def middle_to_after(s): expression = [] ops = [] ss = s.split(' ') for item in ss: if item in ['+', '-', '*', '/']: while len(ops) &gt;= 0: if len(ops) == 0: ops.append(item) break op = ops.pop() if op == '(' or ops_rule[item] &gt; ops_rule[op]: ops.append(op) ops.append(item) break else: expression.append(op) elif item == '(': ops.append(item) elif item == ')': while len(ops) &gt; 0: op = ops.pop() if op == '(': break else: expression.append(op) else: expression.append(item) while len(ops) &gt; 0: expression.append(ops.pop()) return expression (二) 将后缀表达式求值将后缀表达式s_after = “9 3 1 - 3 * + 10 2 / +” 求值,具体的规则如下 ： 初始化一个空栈stack_value，用于存放数值 循环s_after 1、 如果遇到数字，入栈stack_value;2、 如果遇到运算符， 从stack_value中依次出栈两个数（先出栈的在右， 后出栈的在左）连同遍历到的运算符组成二目运算，求值后将结果压栈stack_value3、 继续遍历下一个元素，直到结束 遍历完后stack_value中的结果便是表达式的值 python代码实现如下：12345678910111213141516171819202122232425262728def cal(n1, n2, op): # 四则运算 if op == '+': return n1 + n2 if op == '-': return n1 - n2 if op == '*': return n1 * n2 if op == '/': return n1 / n2 def expression_to_value(expression): stack_value = [] for item in expression: if item in ['+', '-', '*', '/']: n2 = stack_value.pop() # 先出栈的是右操作数 n1 = stack_value.pop() result = cal(n1, n2, item) stack_value.append(result) else: stack_value.append(int(item)) return stack_value[0]if __name__ == '__main__': expression = middle_to_after('9 + ( 3 * ( 4 - 2 ) ) * 3 + 10 / 2') value = expression_to_value(expression) print value]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python， 算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18.3.29前端笔记]]></title>
    <url>%2F2018%2F03%2F29%2F18.3.29%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[屏幕的尺寸标准 超小屏幕（手机） 小屏幕（平板） 中等屏幕（桌面） 大屏幕（桌面） 尺寸 &lt;768px &gt;=768 &gt;=992 &gt;=1200 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 选择器的优先级 优先级 权重 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式 作为style属性写在元素内的样式（内联样式） id选择器 100 类选择器 10 伪类选择器 10 属性选择器 10 标签选择器 1 伪元素选择器 1 通配符选择器 0 优先级是：内联样式 &gt; id 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器 多个选择器组合的时候，不应该简单地给这些选择器分配权值，然后相加比较大小。因为优先级是不能越级的，比方说 1 个 id 选择器能顶你 n 个类选择器…所以要逐级比较，同级的就比较数量，数量多的优先级高。 当然，!important 的优先级最高。 标签的嵌套 标签定义列表项目。 标签可用在有序列表 () 和无序列表 () 中。 标签定义了一个定义列表，定义列表中的条目是通过使用标记(“definition title”，定义标题)和标记(“definition description”，定义描述)创建的。给出了术语名，标记给出了术语的定义。 代表表格 代表表格中的一行 代表表格中的一列 里面只能放，但是里面可以放,等标签。 dt标签和dd标签必须嵌套在dl标签里面，并且dt标签必须位于dd标签前面； tr标签和td标签必须嵌套在table标签里面，其中td标签必须位于tr标签里面。 &lt;ul&gt;&lt;li&gt; &lt;/li&gt;&lt;/ul&gt; &lt;ol&gt;&lt;li&gt; &lt;/li&gt;&lt;/ol&gt; &lt;dl&gt;&lt;dt&gt; &lt;/dt&gt;&lt;dd&gt; &lt;/dd&gt;&lt;/dl&gt; &lt;table&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Ajax与Flash的优缺点 Ajax Flash 优势 1.可搜索性 2.开放性 3.费用 4.易用性 5.易于开发 1.多媒体处理 2.兼容性 3.矢量图形 4.客户端资源调度 劣势 1.它可能破坏浏览器的后退功能 2.使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中 ，不过这些都有相关方法解决 1.二进制格式 2.格式私有 3.flash 文件经常会很大，用户第一次使用的时候需要忍耐较长的等待时间 4.性能问题 Ajax的优势 可搜索性 普通的文本网页会更有利于SEO。文本内容是搜索引擎容易检索的，而繁琐的swf字节码却是搜索引擎不愿触及的。虽然Google等一些大型的搜索引擎可以检索SWF内部的内容，但是仍然有很多麻烦存在。 开放性 Flash常年以来被Macromedia看的很死。包括Flex、FMS等辅佐技术一直都需要昂贵的安装、维护费用。而JS则没有这样的麻烦。没有人愿意承担法律和版权的风险。 费用 Flash开发是很昂贵的，因为FlashIDE等环境都是要收费的．而Ajax则不同．虽然有一些便宜的生成swf的工具，但是他们的工能实在无法满足复杂需求。 易用性 Ajax程序有更好的易用性。由于中间有一层Flashplayer代理层，因此许多辅助功能无法被Flash灵活利用。而且Flash在一些方面有着不好的口碑。比如弹出广告、比如恶意代码。 易于开发 人们开发复杂的Ajax和Flash应用程序时，都会借助一些高级的开发工具。普遍来说，Ajax的开发包比Flash简便、容易。 Flash的优势 多媒体处理 Flash在音频、视频等多媒体领域相比HTML有绝对的优势。现在几乎所有的网站都包含有Flash内容。 兼容性 兼容性好：由于通过了唯一的FlashPlayer“代理”。人们不必像调试JS那样，在不同的浏览器中调试程序。 矢量图型 这是Flash最大的优势，同样处在这一领域的SVG、Canvas element以及Direct完全不能与Flash相比。 客户端资源调度 Flash能够更容易的调用浏览器以外的外部资源。比如摄像头、麦克风等。然而这是普通的HTML无法完成的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器]]></title>
    <url>%2F2018%2F03%2F23%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[基本选择器1234$("#id") //ID选择器$("div") //元素选择器$(".classname") //类选择器$(".classname,.classname1,#id1") //组合选择器 层次选择器1234$("#id&gt;.classname ") //子元素选择器$("#id .classname ") //后代元素选择器$("#id + .classname ") //紧邻下一个元素选择器$("#id ~ .classname ") //兄弟元素选择器 ==过滤选择器==基本过滤选择器12345678$("li:first") //第一个li$("li:last") //最后一个li$("li:even") //挑选下标为偶数的li$("li:odd") //挑选下标为奇数的li$("li:eq(4)") //下标等于4的li$("li:gt(2)") //下标大于2的li$("li:lt(2)") //下标小于2的li$("li:not(#runoob)") //挑选除 id="runoob" 以外的所有li 内容过滤选择器1234$("div:contains('Runob')") // 包含 Runob文本的元素$("td:empty") //不包含子元素或者文本的空元素$("div:has(selector)") //含有选择器所匹配的元素$("td:parent") //含有子元素或者文本的元素 可见性过滤选择器12$("li:hidden") //匹配所有不可见元素，或type为hidden的元素$("li:visible") //匹配所有可见元素 属性过滤选择器12345678$("div[id]") //所有含有 id 属性的 div 元素$("div[id='123']") // id属性值为123的div 元素$("div[id!='123']") // id属性值不等于123的div 元素$("div[id^='qq']") // id属性值以qq开头的div 元素$("div[id$='zz']") // id属性值以zz结尾的div 元素$("div[id~='aa']") // id属性值为aa的div 元素$("div[id*='bb']") // id属性值包含bb的div 元素$("input[id][name$='man']") //多属性选过滤，同时满足两个属性的条件的元素 状态过滤选择器1234$("input:enabled") // 匹配可用的 input$("input:disabled") // 匹配不可用的 input$("input:checked") // 匹配选中的 input$("option:selected") // 匹配选中的 option 表单选择器123456789$(":input") //匹配所有 input, textarea, select 和 button 元素$(":text") //所有的单行文本框，$(":text") 等价于$("[type=text]")，推荐使用$("input:text")效率更高，下同$(":password") //所有密码框$(":radio") //所有单选按钮$(":checkbox") //所有复选框$(":submit") //所有提交按钮$(":reset") //所有重置按钮$(":button") //所有button按钮$(":file") //所有文件域 转自菜鸟教程]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs笔记]]></title>
    <url>%2F2018%2F03%2F21%2Fnodejs%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[常用网站 nodejs.org看看nodejs的版本升级，新特性的加入，重要bug的修复等 www.npmjs.com模块社区，看他人源代码，省力 github.com大量的项目和源码 stackoverflow.com技术解答社区以及查询相关资源，环境配置，异常均可找到答案]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛顿迭代法求平方根]]></title>
    <url>%2F2018%2F03%2F19%2F%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[牛顿迭代法从函数意义上理解：我们是要求函数f(x) = x²，使f(x) = num的近似解，即x² - num = 0的近似解。 从几何意义上理解：我们是要求抛物线g(x) = x² - num与x轴交点（g(x) = 0）最接近的点。 我们假设g(x0)=0，即x0是正解，那么我们要做的就是让近似解x不断逼近x0。 先任取一个初始值xi，经过这个点（xi,f(xi)）的切线方程为 f(x) = f(xi) + f′(xi)(x−xi)，令切线方程等于0 (纵轴截距取0)，即可求出： 可以由此得到 从几何图形上看，因为导数是切线，通过不断迭代，导数与x轴的交点会不断逼近x0。 123456789def mySqrt(self, x): """ :type x: int :rtype: int """ r = x while r*r &gt; x: r = (r + x/r) / 2 return r]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据结构-链表]]></title>
    <url>%2F2018%2F03%2F18%2Fpython%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[python实现链表依赖于类生成的实例，每个节点都是一个对象，组合在一起形成一个完整链表 对于node类只需关注两点：value 和 next对于linked_list需要关心的：head（头结点，默认是node），length（列表的长度） 链表的数据结构如下图所示： 链表的实现定义链表定义节点类Node123456789101112class Node: def __init__(self, value): ''' value: 节点保存的数据，next: 保存下一个节点对象 ''' self.val = value self.next = None def __repr__(self): ''' 用来定义Node的字符输出，print为输出value ''' return str(self.value) 操作链表定义链表类LinkedList链表要包括：属性：链表头：head链表长度：length 方法： is_empty() 链表是否为空 add(item) 链表头部添加元素 append(item) 链表尾部添加元素 insert(index, item) 指定位置添加元素 delete(index) 删除指定位置节点 remove(item) 删除某个数值节点 search(item) 查找节点是否存在 判断是否为空: is_Empty()12def is_empty(self): return self.length == 0 头部添加一个节点：add()123456def add(self, item): node = Node(item) # 将新节点的链接域next指向头节点，即head指向的位置 node.next = self.head # 将链表的头head指向新节点 self.head = node 尾部添加一个节点：append()12345678910111213def append(self, item): # 确保item是node对象 item = Node(item) # 先判断链表是否为空，若是空链表，则将head指向新节点 if self.is_empty(): self.head = node # 若不为空，则找到尾部，将尾节点的next指向新节点 else: node = self.head while node.next: node = node.next node.next = item self.length += 1 指定位置添加节点：insert()12345678910111213141516171819202122def insert(self, index, item): # 若指定位置pos为第一个元素之前，则执行头部插入 if index &lt;= 0: self.add(item) # 若指定位置超过链表尾部，则执行尾部插入 elif index &gt; (self.length()-1): self.append(item) # 找到指定位置 else: node = Node(item) # 从头节点开始移动到插入位置的前一个节点 pre = self.head while index-1: pre = pre.next index -= 1 # 先将新节点node的next指向插入位置的节点 node.next = pre.next # 将插入位置的前一个节点的next指向新节点 pre.next = node self.length += 1 删除数值是item的节点：remove(item)12345678910111213141516171819def remove(self, item): pre = None # 前一个节点 cur = self.head # 当前节点 while cur: # 找到了指定元素 if cur.item == item: # 如果第一个就是删除的节点 if not pre: # 将头指针指向头节点的后一个节点 self.head = cur.next else: # 将删除位置前一个节点的next指向删除位置的后一个节点 pre.next = cur.next self.length -= 1 break else: # 继续按链表后移节点 pre = cur cur = cur.next 删除某个位置的节点：delete(index)123456789101112131415def delete(self, index): if index &gt; self.length: # 索引值超出范围直接提示并且退出 print("Index is out of range.") return else: if index == 0: self.head = self.head.next else: pre = self.head while index - 1: pre = pre.next index -= 1 pre.next = pre.next.pnext self.length -= 1 查找节点是否存在：search()12345678def search(self,item): """链表查找节点是否存在，并返回True或者False""" cur = self.head while cur != None: if cur.item == item: return True cur = cur.next return False]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客-优化篇]]></title>
    <url>%2F2018%2F03%2F15%2Fhexo%E5%8D%9A%E5%AE%A2-%E4%BC%98%E5%8C%96%E7%AF%87%2F</url>
    <content type="text"><![CDATA[在文章中插入图片在source目录下新建一个img文件夹，将图片放入该文件夹下 插入图片时将链接写为/img/图片名称 设置鼠标经过头像时头像旋转打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 设置侧边栏的社交图标打开主题配置文件themes\next\_config.yml，搜索social_icons,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 注意：第一次操作时记得将social和你希望添加的社交地址前面的#去掉 为文章添加阴影边框打开\themes\next\source\css\_custom\custom.styl,向里面加入：12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 在网站底部添加访问量打开\themes\next\layout\_partials\footer.swig文件,在copyright前添加async src123456```&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 如下图所示： 为文章实现统计功能在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 打开主题配置文件themes\next\_config.yml，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 这时我们发现文章的【字数统计】和【阅读时长】后面没有对应的xxx字，xx分钟等单位，所以接下来打开themes\next\layout\_macro\post.swig文件在对应为位置添加如下字样： 刷新之后出现乱码将文件保存为UTF-8即可解决 首页文章设置为只显示预览打开主题配置文件themes\next\_config.yml搜索”auto_excerpt”,找到如下部分：12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 把enable改为对应的false改为true即可 在文章底部添加jiathis分享打开主题配置文件themes\next\_config.yml中，设置jiathis: true，即打开了jiathis分享，如下图所示： 想自定义话，打开themes\next\layout\_partials\share\jiathis.swig修改每一个部分就可以了 class123456789&lt;span class=&quot;jiathis_txt&quot;&gt;分享到：&lt;/span&gt; &lt;a class=&quot;jiathis_button_fav&quot;&gt;收藏夹&lt;/a&gt; &lt;a class=&quot;jiathis_button_copy&quot;&gt;复制网址&lt;/a&gt; &lt;a class=&quot;jiathis_button_email&quot;&gt;邮件&lt;/a&gt; &lt;a class=&quot;jiathis_button_weixin&quot;&gt;微信&lt;/a&gt; &lt;a class=&quot;jiathis_button_cqq&quot;&gt;QQ&lt;/a&gt; &lt;a class=&quot;jiathis_button_tsina&quot;&gt;新浪微博&lt;/a&gt; &lt;a class=&quot;jiathis_button_douban&quot;&gt;豆瓣&lt;/a&gt; &lt;a class=&quot;jiathis_button_share&quot;&gt;一键分享&lt;/a&gt; 修改文章底部标签的“#”打开\themes\next\layout\_macro\post.swig 搜索 rel=&quot;tag&quot;&gt;# 将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;即可]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文档坐标和视口坐标]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%96%87%E6%A1%A3%E5%9D%90%E6%A0%87%E5%92%8C%E8%A7%86%E5%8F%A3%E5%9D%90%E6%A0%87%2F</url>
    <content type="text"><![CDATA[文档坐标和视口坐标视口坐标是相对于窗口的坐标，而文档坐标是相对于整个文档而言。例如，在文档坐标中如果一个元素的相对于文档的Y坐标是200px，并且用户已经把浏览器向下滚动了75px，那么视口坐标中元素的Y坐标为200px– 75px = 125px。]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
